{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///Users/sharanr/Documents/Valtech/Others/AI-Hackathon/autodev.ai/autodev-ui/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from \"next-auth\"\nimport type { NextAuthOptions } from \"next-auth\"\n\nexport const authOptions: NextAuthOptions = {\n  providers: [\n    {\n      id: \"atlassian\",\n      name: \"Atlassian\",\n      type: \"oauth\",\n      authorization: {\n        url: \"https://auth.atlassian.com/authorize\",\n        params: {\n          audience: \"api.atlassian.com\",\n          prompt: \"consent\",\n          scope: \"read:me read:account offline_access read:jira-work read:jira-user read:confluence-content.all read:confluence-user\"\n        }\n      },\n      token: \"https://auth.atlassian.com/oauth/token\",\n      userinfo: {\n        url: \"https://api.atlassian.com/me\",\n        async request({ tokens }) {\n          console.log('Fetching user info with token:', tokens.access_token?.substring(0, 20) + '...')\n          const res = await fetch(\"https://api.atlassian.com/me\", {\n            headers: {\n              Authorization: `Bearer ${tokens.access_token}`,\n            },\n          })\n          const data = await res.json()\n          console.log('User info response:', data)\n          return data\n        }\n      },\n      profile(profile) {\n        return {\n          id: profile.account_id,\n          name: profile.name,\n          email: profile.email,\n          image: profile.picture\n        }\n      },\n      clientId: process.env.ATLASSIAN_CLIENT_ID,\n      clientSecret: process.env.ATLASSIAN_CLIENT_SECRET,\n    }\n  ],\n  callbacks: {\n    async jwt({ token, account, profile }) {\n      console.log('JWT Callback - Account:', account)\n      console.log('JWT Callback - Profile:', profile)\n      console.log('JWT Callback - Token before:', token)\n      \n      if (account) {\n        token.accessToken = account.access_token\n        token.refreshToken = account.refresh_token\n        token.accessTokenExpires = account.expires_at ? account.expires_at * 1000 : Date.now() + 10 * 60 * 60 * 1000 // 10 hours\n      }\n      if (profile) {\n        token.name = profile.name\n        token.email = profile.email\n        token.picture = profile.picture\n      }\n      \n      console.log('JWT Callback - Token after:', token)\n      return token\n    },\n    async session({ session, token }) {\n      console.log('Session Callback - Token:', token)\n      console.log('Session Callback - Session before:', session)\n      \n      session.accessToken = token.accessToken as string\n      session.user = {\n        name: token.name as string,\n        email: token.email as string,\n        image: token.picture as string,\n      }\n      \n      console.log('Session Callback - Session after:', session)\n      return session\n    }\n  },\n  pages: {\n    signIn: '/login',\n    signOut: '/signout',\n    error: '/login', // Redirect to login page on error\n  },\n  session: {\n    strategy: \"jwt\",\n    maxAge: 10 * 60 * 60, // 10 hours in seconds\n  },\n  debug: true, // Enable debug mode to see detailed error logs\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAGO,MAAM,cAA+B;IAC1C,WAAW;QACT;YACE,IAAI;YACJ,MAAM;YACN,MAAM;YACN,eAAe;gBACb,KAAK;gBACL,QAAQ;oBACN,UAAU;oBACV,QAAQ;oBACR,OAAO;gBACT;YACF;YACA,OAAO;YACP,UAAU;gBACR,KAAK;gBACL,MAAM,SAAQ,EAAE,MAAM,EAAE;oBACtB,QAAQ,GAAG,CAAC,kCAAkC,OAAO,YAAY,EAAE,UAAU,GAAG,MAAM;oBACtF,MAAM,MAAM,MAAM,MAAM,gCAAgC;wBACtD,SAAS;4BACP,eAAe,CAAC,OAAO,EAAE,OAAO,YAAY,EAAE;wBAChD;oBACF;oBACA,MAAM,OAAO,MAAM,IAAI,IAAI;oBAC3B,QAAQ,GAAG,CAAC,uBAAuB;oBACnC,OAAO;gBACT;YACF;YACA,SAAQ,OAAO;gBACb,OAAO;oBACL,IAAI,QAAQ,UAAU;oBACtB,MAAM,QAAQ,IAAI;oBAClB,OAAO,QAAQ,KAAK;oBACpB,OAAO,QAAQ,OAAO;gBACxB;YACF;YACA,UAAU,QAAQ,GAAG,CAAC,mBAAmB;YACzC,cAAc,QAAQ,GAAG,CAAC,uBAAuB;QACnD;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE;YACnC,QAAQ,GAAG,CAAC,2BAA2B;YACvC,QAAQ,GAAG,CAAC,2BAA2B;YACvC,QAAQ,GAAG,CAAC,gCAAgC;YAE5C,IAAI,SAAS;gBACX,MAAM,WAAW,GAAG,QAAQ,YAAY;gBACxC,MAAM,YAAY,GAAG,QAAQ,aAAa;gBAC1C,MAAM,kBAAkB,GAAG,QAAQ,UAAU,GAAG,QAAQ,UAAU,GAAG,OAAO,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,MAAK,WAAW;YAC1H;YACA,IAAI,SAAS;gBACX,MAAM,IAAI,GAAG,QAAQ,IAAI;gBACzB,MAAM,KAAK,GAAG,QAAQ,KAAK;gBAC3B,MAAM,OAAO,GAAG,QAAQ,OAAO;YACjC;YAEA,QAAQ,GAAG,CAAC,+BAA+B;YAC3C,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,QAAQ,GAAG,CAAC,6BAA6B;YACzC,QAAQ,GAAG,CAAC,sCAAsC;YAElD,QAAQ,WAAW,GAAG,MAAM,WAAW;YACvC,QAAQ,IAAI,GAAG;gBACb,MAAM,MAAM,IAAI;gBAChB,OAAO,MAAM,KAAK;gBAClB,OAAO,MAAM,OAAO;YACtB;YAEA,QAAQ,GAAG,CAAC,qCAAqC;YACjD,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;QACR,SAAS;QACT,OAAO;IACT;IACA,SAAS;QACP,UAAU;QACV,QAAQ,KAAK,KAAK;IACpB;IACA,OAAO;AACT;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC"}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":["file:///Users/sharanr/Documents/Valtech/Others/AI-Hackathon/autodev.ai/autodev-ui/app/api/jira/user-suggestions/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '../../auth/[...nextauth]/route';\nimport OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.accessToken) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    if (!process.env.OPENAI_API_KEY) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });\n    }\n\n    // Get accessible Jira resources\n    const resourcesRes = await fetch('https://api.atlassian.com/oauth/token/accessible-resources', {\n      headers: {\n        'Authorization': `Bearer ${session.accessToken}`,\n        'Accept': 'application/json',\n      },\n    });\n\n    if (!resourcesRes.ok) {\n      if (resourcesRes.status === 401) {\n        return NextResponse.json({ error: 'Session expired', logout: true }, { status: 401 });\n      }\n      throw new Error('Failed to fetch accessible resources');\n    }\n\n    const resources = await resourcesRes.json();\n    \n    if (!resources || resources.length === 0) {\n      return NextResponse.json({ error: 'No Jira sites found' }, { status: 404 });\n    }\n\n    const cloudId = resources[0].id;\n\n    // Fetch user's current tickets (assigned to them)\n    const userTicketsRes = await fetch(\n      `https://api.atlassian.com/ex/jira/${cloudId}/rest/api/3/search/jql`,\n      {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${session.accessToken}`,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          jql: `project = SA AND assignee = currentUser() AND status != Done ORDER BY updated DESC`,\n          maxResults: 50,\n          fields: ['summary', 'description', 'status', 'issuetype', 'sprint']\n        })\n      }\n    );\n\n    if (!userTicketsRes.ok) {\n      throw new Error('Failed to fetch user tickets');\n    }\n\n    const userTicketsData = await userTicketsRes.json();\n    const userTickets = userTicketsData.issues || [];\n    \n    console.log(`\\n=== Finding suggestions for ${userTickets.length} user tickets ===`);\n\n    // Fetch unassigned tickets from current sprint and backlog\n    const unassignedTicketsRes = await fetch(\n      `https://api.atlassian.com/ex/jira/${cloudId}/rest/api/3/search/jql`,\n      {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${session.accessToken}`,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          jql: `project = SA AND assignee is EMPTY AND status != Done ORDER BY updated DESC`,\n          maxResults: 100,\n          fields: ['summary', 'description', 'status', 'issuetype', 'sprint', 'created']\n        })\n      }\n    );\n\n    const unassignedTicketsData = unassignedTicketsRes.ok ? (await unassignedTicketsRes.json()).issues || [] : [];\n    \n    console.log(`Found ${unassignedTicketsData.length} unassigned tickets`);\n\n    // Helper function to extract description text from Jira's ADF format or plain text\n    const extractDescription = (descriptionField: any): string => {\n      if (!descriptionField) return '';\n      \n      // Handle Atlassian Document Format (ADF)\n      if (descriptionField.content && Array.isArray(descriptionField.content)) {\n        return descriptionField.content\n          .map((node: any) => {\n            if (node.type === 'paragraph' && node.content) {\n              return node.content.map((c: any) => c.text || '').join(' ');\n            }\n            return '';\n          })\n          .join(' ');\n      }\n      \n      // Handle plain text\n      return String(descriptionField);\n    };\n\n    // Process each user ticket to find relevant unassigned tickets\n    const suggestions = await Promise.all(\n      userTickets.map(async (userTicket: any) => {\n        const currentTicketSummary = userTicket.fields.summary || '';\n        const currentTicketDescription = extractDescription(userTicket.fields.description) || 'No description';\n        \n        console.log(`\\n--- Analyzing ${userTicket.key}: \"${currentTicketSummary}\" ---`);\n\n        // Categorize unassigned tickets\n        const categorizedTickets = unassignedTicketsData.map((ticket: any) => {\n          const hasSprint = ticket.fields.sprint && ticket.fields.sprint.length > 0;\n          const status = ticket.fields.status?.name?.toLowerCase() || '';\n          \n          let category: 'current-sprint' | 'backlog' = 'backlog';\n          if (hasSprint && !status.includes('backlog')) {\n            category = 'current-sprint';\n          }\n          \n          return {\n            ...ticket,\n            category\n          };\n        });\n\n        // Prepare tickets for LLM analysis\n        const ticketsForAnalysis = categorizedTickets.map((ticket: any) => ({\n          key: ticket.key,\n          summary: ticket.fields.summary,\n          description: extractDescription(ticket.fields.description) || 'No description',\n          category: ticket.category,\n          status: ticket.fields.status?.name\n        }));\n\n        if (ticketsForAnalysis.length === 0) {\n          return {\n            ticketKey: userTicket.key,\n            title: currentTicketSummary,\n            suggestions: [],\n            confidence: 0,\n            lastUpdated: new Date().toISOString(),\n          };\n        }\n\n        // Use OpenAI to analyze relevance\n        const prompt = `You are an expert software development project manager analyzing Jira tickets for relevance.\n\nCURRENT TICKET (that the developer is working on):\nKey: ${userTicket.key}\nSummary: ${currentTicketSummary}\nDescription: ${currentTicketDescription}\n\nTASK: Analyze the following unassigned tickets and identify which ones are HIGHLY relevant to the current ticket. Look for:\n1. Similar technical components (e.g., same database tables, UI components, APIs)\n2. Related features or functionality\n3. Shared domain concepts or business logic\n4. Dependencies or prerequisite work\n5. Common technical challenges\n\nOnly return tickets with 70% or higher relevance.\n\nUNASSIGNED TICKETS TO ANALYZE:\n${ticketsForAnalysis.map((t, i) => `\n${i + 1}. ${t.key} [${t.category === 'current-sprint' ? 'CURRENT SPRINT' : 'BACKLOG'}]\n   Summary: ${t.summary}\n   Description: ${t.description}\n   Status: ${t.status}\n`).join('\\n')}\n\nRESPONSE FORMAT (JSON only, no markdown):\n{\n  \"relevant_tickets\": [\n    {\n      \"key\": \"ticket-key\",\n      \"relevance_score\": 85,\n      \"reasoning\": \"brief explanation of why this ticket is relevant\",\n      \"category\": \"current-sprint\" or \"backlog\"\n    }\n  ]\n}\n\nOnly include tickets with relevance_score >= 70. Return empty array if no tickets meet the threshold.`;\n\n        try {\n          console.log(`Calling OpenAI for ${userTicket.key}...`);\n          \n          const completion = await openai.chat.completions.create({\n            model: \"gpt-4o-mini\",\n            messages: [\n              {\n                role: \"system\",\n                content: \"You are a technical project manager expert at analyzing software development tickets. Respond only with valid JSON.\"\n              },\n              {\n                role: \"user\",\n                content: prompt\n              }\n            ],\n            temperature: 0,\n            max_tokens: 2000,\n          });\n\n          const responseText = completion.choices[0]?.message?.content || '{}';\n          console.log(`OpenAI response for ${userTicket.key}:`, responseText);\n          \n          // Parse the response\n          const llmResponse = JSON.parse(responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, ''));\n          const relevantTickets = llmResponse.relevant_tickets || [];\n\n          console.log(`Found ${relevantTickets.length} relevant tickets from LLM`);\n\n          // Map the results\n          const mappedTickets = relevantTickets.map((item: any) => {\n            const originalTicket = categorizedTickets.find(t => t.key === item.key);\n            return {\n              key: item.key,\n              summary: originalTicket?.fields.summary || '',\n              status: originalTicket?.fields.status?.name || 'Unknown',\n              relevance: item.relevance_score,\n              category: item.category,\n              assignee: 'Unassigned',\n              reasoning: item.reasoning\n            };\n          });\n\n          return {\n            ticketKey: userTicket.key,\n            title: currentTicketSummary,\n            suggestions: mappedTickets,\n            confidence: mappedTickets.length > 0 ? Math.min(mappedTickets[0].relevance / 100, 0.95) : 0,\n            lastUpdated: new Date().toISOString(),\n          };\n\n        } catch (error: any) {\n          console.error(`Error calling OpenAI for ${userTicket.key}:`, error.message);\n          return {\n            ticketKey: userTicket.key,\n            title: currentTicketSummary,\n            suggestions: [],\n            confidence: 0,\n            lastUpdated: new Date().toISOString(),\n          };\n        }\n      })\n    );\n\n    // Filter out tickets with no suggestions\n    const validSuggestions = suggestions.filter(s => s.suggestions.length > 0);\n    \n    console.log(`\\n=== Total suggestions generated: ${validSuggestions.length} ===\\n`);\n\n    return NextResponse.json({ suggestions: validSuggestions });\n\n  } catch (error: any) {\n    console.error('Error in user-suggestions:', error);\n    return NextResponse.json(\n      { error: error.message || 'Failed to fetch suggestions' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}