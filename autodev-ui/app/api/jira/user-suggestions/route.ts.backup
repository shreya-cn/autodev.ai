import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '../../auth/[...nextauth]/route';
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.accessToken) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });
    }

    // Get accessible Jira resources
    const resourcesRes = await fetch('https://api.atlassian.com/oauth/token/accessible-resources', {
      headers: {
        'Authorization': `Bearer ${session.accessToken}`,
        'Accept': 'application/json',
      },
    });

    if (!resourcesRes.ok) {
      throw new Error('Failed to fetch accessible resources');
    }

    const resources = await resourcesRes.json();
    
    if (!resources || resources.length === 0) {
      return NextResponse.json({ error: 'No Jira sites found' }, { status: 404 });
    }

    const cloudId = resources[0].id;

    // Fetch user's current tickets (assigned to them)
    const userTicketsRes = await fetch(
      `https://api.atlassian.com/ex/jira/${cloudId}/rest/api/3/search/jql`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.accessToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jql: `project = SA AND assignee = currentUser() AND status != Done ORDER BY updated DESC`,
          maxResults: 50,
          fields: ['summary', 'description', 'status', 'issuetype', 'sprint']
        })
      }
    );

    if (!userTicketsRes.ok) {
      throw new Error('Failed to fetch user tickets');
    }

    const userTicketsData = await userTicketsRes.json();
    const userTickets = userTicketsData.issues || [];
    
    console.log(`\n=== Finding suggestions for ${userTickets.length} user tickets ===`);

    // Fetch unassigned tickets from current sprint and backlog
    const unassignedTicketsRes = await fetch(
      `https://api.atlassian.com/ex/jira/${cloudId}/rest/api/3/search/jql`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.accessToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jql: `project = SA AND assignee is EMPTY AND status != Done ORDER BY updated DESC`,
          maxResults: 100,
          fields: ['summary', 'description', 'status', 'issuetype', 'sprint', 'created']
        })
      }
    );

    const unassignedTicketsData = unassignedTicketsRes.ok ? (await unassignedTicketsRes.json()).issues || [] : [];
    
    console.log(`Found ${unassignedTicketsData.length} unassigned tickets`);

    // Helper function to extract description text from Jira's ADF format or plain text
    const extractDescription = (descriptionField: any): string => {
      if (!descriptionField) return '';
      
      // Handle Atlassian Document Format (ADF)
      if (descriptionField.content && Array.isArray(descriptionField.content)) {
        return descriptionField.content
          .map((node: any) => {
            if (node.type === 'paragraph' && node.content) {
              return node.content.map((c: any) => c.text || '').join(' ');
            }
            return '';
          })
          .join(' ');
      }
      
      // Handle plain text
      return String(descriptionField);
    };

    // Process each user ticket to find relevant unassigned tickets
    const suggestions = await Promise.all(
      userTickets.map(async (userTicket: any) => {
        const currentTicketSummary = userTicket.fields.summary || '';
        const currentTicketDescription = extractDescription(userTicket.fields.description) || 'No description';
        
        console.log(`\n--- Analyzing ${userTicket.key}: "${currentTicketSummary}" ---`);

        // Categorize unassigned tickets
        const categorizedTickets = unassignedTicketsData.map((ticket: any) => {
          const hasSprint = ticket.fields.sprint && ticket.fields.sprint.length > 0;
          const status = ticket.fields.status?.name?.toLowerCase() || '';
          
          let category: 'current-sprint' | 'backlog' = 'backlog';
          if (hasSprint && !status.includes('backlog')) {
            category = 'current-sprint';
          }
          
          return {
            ...ticket,
            category
          };
        });

        // Prepare tickets for LLM analysis
        const ticketsForAnalysis = categorizedTickets.map((ticket: any) => ({
          key: ticket.key,
          summary: ticket.fields.summary,
          description: extractDescription(ticket.fields.description) || 'No description',
          category: ticket.category,
          status: ticket.fields.status?.name
        }));

        if (ticketsForAnalysis.length === 0) {
          return {
            ticketKey: userTicket.key,
            title: currentTicketSummary,
            suggestions: [],
            confidence: 0,
            lastUpdated: new Date().toISOString(),
          };
        }

        // Use OpenAI to analyze relevance
        const prompt = `You are an expert software development project manager analyzing Jira tickets for relevance.

CURRENT TICKET (that the developer is working on):
Key: ${userTicket.key}
Summary: ${currentTicketSummary}
Description: ${currentTicketDescription}

TASK: Analyze the following unassigned tickets and identify which ones are HIGHLY relevant to the current ticket. Look for:
1. Similar technical components (e.g., same database tables, UI components, APIs)
2. Related features or functionality
3. Shared domain concepts or business logic
4. Dependencies or prerequisite work
5. Common technical challenges

Only return tickets with 70% or higher relevance.

UNASSIGNED TICKETS TO ANALYZE:
${ticketsForAnalysis.map((t, i) => `
${i + 1}. ${t.key} [${t.category === 'current-sprint' ? 'CURRENT SPRINT' : 'BACKLOG'}]
   Summary: ${t.summary}
   Description: ${t.description}
   Status: ${t.status}
`).join('\n')}

RESPONSE FORMAT (JSON only, no markdown):
{
  "relevant_tickets": [
    {
      "key": "ticket-key",
      "relevance_score": 85,
      "reasoning": "brief explanation of why this ticket is relevant",
      "category": "current-sprint" or "backlog"
    }
  ]
}

Only include tickets with relevance_score >= 70. Return empty array if no tickets meet the threshold.`;

        try {
          console.log(`Calling OpenAI for ${userTicket.key}...`);
          
          const completion = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [
              {
                role: "system",
                content: "You are a technical project manager expert at analyzing software development tickets. Respond only with valid JSON."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            temperature: 0.3,
            max_tokens: 2000,
          });

          const responseText = completion.choices[0]?.message?.content || '{}';
          console.log(`OpenAI response for ${userTicket.key}:`, responseText);
          
          // Parse the response
          const llmResponse = JSON.parse(responseText.replace(/```json\n?/g, '').replace(/```\n?/g, ''));
          const relevantTickets = llmResponse.relevant_tickets || [];

          console.log(`Found ${relevantTickets.length} relevant tickets from LLM`);

          // Map the results
          const mappedTickets = relevantTickets.map((item: any) => {
            const originalTicket = categorizedTickets.find(t => t.key === item.key);
            return {
              key: item.key,
              summary: originalTicket?.fields.summary || '',
              status: originalTicket?.fields.status?.name || 'Unknown',
              relevance: item.relevance_score,
              category: item.category,
              assignee: 'Unassigned',
              reasoning: item.reasoning
            };
          });

          return {
            ticketKey: userTicket.key,
            title: currentTicketSummary,
            suggestions: mappedTickets,
            confidence: mappedTickets.length > 0 ? Math.min(mappedTickets[0].relevance / 100, 0.95) : 0,
            lastUpdated: new Date().toISOString(),
          };

        } catch (error: any) {
          console.error(`Error calling OpenAI for ${userTicket.key}:`, error.message);
          return {
            ticketKey: userTicket.key,
            title: currentTicketSummary,
            suggestions: [],
            confidence: 0,
            lastUpdated: new Date().toISOString(),
          };
        }
      })
    );

    // Filter out tickets with no suggestions
    const validSuggestions = suggestions.filter(s => s.suggestions.length > 0);
    
    console.log(`\n=== Total suggestions generated: ${validSuggestions.length} ===\n`);

    return NextResponse.json({ suggestions: validSuggestions });

  } catch (error: any) {
    console.error('Error in user-suggestions:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to fetch suggestions' },
      { status: 500 }
    );
  }
}
    const session = await getServerSession(authOptions);
    
    if (!session?.accessToken) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get accessible Jira resources
    const resourcesRes = await fetch('https://api.atlassian.com/oauth/token/accessible-resources', {
      headers: {
        'Authorization': `Bearer ${session.accessToken}`,
        'Accept': 'application/json',
      },
    });

    if (!resourcesRes.ok) {
      throw new Error('Failed to fetch accessible resources');
    }

    const resources = await resourcesRes.json();
    
    if (!resources || resources.length === 0) {
      return NextResponse.json({ error: 'No Jira sites found' }, { status: 404 });
    }

    const cloudId = resources[0].id;

    // Fetch user's tickets from SA project (only assigned tickets) for suggestions
    const jql = `project = SA AND assignee = currentUser() ORDER BY updated DESC`;
    
    const ticketsRes = await fetch(
      `https://api.atlassian.com/ex/jira/${cloudId}/rest/api/3/search/jql`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.accessToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jql: jql,
          maxResults: 50,
          fields: ['summary', 'description', 'status', 'issuetype', 'labels', 'components', 'assignee']
        })
      }
    );

    if (!ticketsRes.ok) {
      throw new Error('Failed to fetch tickets for suggestions');
    }

    const ticketsData = await ticketsRes.json();
    console.log('Total tickets fetched for suggestions:', ticketsData.issues?.length || 0);

    // Helper function to extract meaningful keywords and phrases
    const extractKeywords = (text: string): string[] => {
      if (!text) return [];
      
      const commonWords = new Set(['the', 'is', 'are', 'was', 'were', 'will', 'be', 'been', 'being', 
        'have', 'has', 'had', 'do', 'does', 'did', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 
        'to', 'for', 'of', 'as', 'by', 'with', 'from', 'this', 'that']);
      
      const lowerText = text.toLowerCase();
      const keywords: string[] = [];
      
      // Extract compound terms (e.g., "user-details table", "insert button")
      const compoundPattern = /([a-z]+(?:-[a-z]+)+(?:\s+[a-z]+)?|[a-z]+\s+[a-z]+(?:\s+table|\s+button|\s+column|\s+field))/g;
      const compounds = lowerText.match(compoundPattern) || [];
      keywords.push(...compounds);
      
      // Extract individual words
      const words = lowerText
        .replace(/[^\w\s-]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 2 && !commonWords.has(word));
      
      keywords.push(...words);
      
      return keywords;
    };

    // Helper function to calculate similarity score based on text matching
    const calculateSimilarity = (text1: string, text2: string): number => {
      if (!text1 || !text2) return 0;
      
      const words1 = extractKeywords(text1);
      const words2 = extractKeywords(text2);
      
      if (words1.length === 0 || words2.length === 0) return 0;
      
      // Count common keywords
      const commonWords = words1.filter(word => words2.includes(word));
      
      // Calculate Jaccard similarity
      const union = new Set([...words1, ...words2]).size;
      const intersection = commonWords.length;
      let score = intersection / union;
      
      // Bonus for matching compound terms (multi-word phrases)
      const compoundMatches = commonWords.filter(word => word.includes(' ') || word.includes('-'));
      if (compoundMatches.length > 0) {
        // Each compound match adds 15% bonus
        score += compoundMatches.length * 0.15;
      }
      
      return Math.min(score, 1.0);
    };

    // Helper function to extract description text from Jira's ADF format or plain text
    const extractDescription = (descriptionField: any): string => {
      if (!descriptionField) return '';
      
      // Handle Atlassian Document Format (ADF)
      if (descriptionField.content && Array.isArray(descriptionField.content)) {
        return descriptionField.content
          .map((node: any) => {
            if (node.type === 'paragraph' && node.content) {
              return node.content.map((c: any) => c.text || '').join(' ');
            }
            return '';
          })
          .join(' ');
      }
      
      // Handle plain text
      return String(descriptionField);
    };

    // Transform to suggestions format with description-based relevance (70%) and summary-based (30%)
    const allTickets = ticketsData.issues || [];
    console.log('Processing tickets for suggestions:', allTickets.length);
    
    // Get all tickets from the project for comparison (not just assigned ones)
    const allProjectTicketsRes = await fetch(
      `https://api.atlassian.com/ex/jira/${cloudId}/rest/api/3/search/jql`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.accessToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jql: `project = SA ORDER BY updated DESC`,
          maxResults: 100,
          fields: ['summary', 'description', 'status', 'issuetype', 'labels', 'components', 'assignee', 'sprint']
        })
      }
    );
    
    const allProjectTickets = allProjectTicketsRes.ok ? (await allProjectTicketsRes.json()).issues || [] : [];
    console.log('All project tickets for comparison:', allProjectTickets.length);
    
    const suggestions = allTickets.map((issue: any) => {
      const issueDescription = extractDescription(issue.fields.description);
      const issueSummary = issue.fields.summary || '';
      
      console.log(`\n=== Analyzing ${issue.key}: "${issueSummary}" ===`);
      console.log(`Description: "${issueDescription}"`);
      const issueKeywords = extractKeywords(issueSummary + ' ' + issueDescription);
      console.log(`Keywords extracted: [${issueKeywords.join(', ')}]`);
      
      // Find related tickets from all project tickets
      const relatedTickets = allProjectTickets
        .filter((other: any) => other.key !== issue.key)
        .map((other: any) => {
          const otherDescription = extractDescription(other.fields.description);
          const otherSummary = other.fields.summary || '';
          
          // Calculate similarity scores
          const descriptionSimilarity = calculateSimilarity(issueDescription, otherDescription);
          const summarySimilarity = calculateSimilarity(issueSummary, otherSummary);
          
          // Weighted score: 70% description, 30% summary
          let totalScore = (descriptionSimilarity * 0.7) + (summarySimilarity * 0.3);
          
          // Also consider labels and components as bonus
          const issueLabels = issue.fields.labels || [];
          const otherLabels = other.fields.labels || [];
          const commonLabels = issueLabels.filter((label: string) => otherLabels.includes(label));
          
          const issueComponents = (issue.fields.components || []).map((c: any) => c.name);
          const otherComponents = (other.fields.components || []).map((c: any) => c.name);
          const commonComponents = issueComponents.filter((comp: string) => otherComponents.includes(comp));
          
          const bonusScore = (commonLabels.length * 0.1) + (commonComponents.length * 0.1);
          totalScore = Math.min(totalScore + bonusScore, 1.0);
          
          // Determine ticket category
          const status = other.fields.status?.name?.toLowerCase() || '';
          const assignee = other.fields.assignee;
          const sprint = other.fields.sprint; // Will be undefined if not in sprint
          
          let category = 'current';
          if (!assignee) {
            category = 'unassigned';
          } else if (status.includes('backlog') || (status.includes('to do') && !sprint)) {
            category = 'backlog';
          }
          
          const otherKeywords = extractKeywords(otherSummary + ' ' + otherDescription);
          const matchedKeywords = issueKeywords.filter(k => otherKeywords.includes(k));
          console.log(`  Comparing with ${other.key} ("${otherSummary}")`);
          console.log(`    Desc similarity: ${(descriptionSimilarity * 100).toFixed(2)}%, Summary similarity: ${(summarySimilarity * 100).toFixed(2)}%`);
          console.log(`    Matched keywords: [${matchedKeywords.join(', ')}]`);
          console.log(`    Total score: ${(totalScore * 100).toFixed(2)}%, assignee=${assignee?.displayName || 'none'}, category=${category}`);
          
          return {
            ticket: other,
            score: totalScore,
            category: category,
            assignee: assignee
          };
        })
        .filter(item => {
          // Only show tickets that are:
          // 1. At least 70% relevant
          // 2. Either unassigned OR in backlog/not in current sprint
          const meetsRelevanceThreshold = item.score >= 0.7;
          const isUnassignedOrBacklog = !item.assignee || item.category === 'backlog' || item.category === 'unassigned';
          
          if (meetsRelevanceThreshold && isUnassignedOrBacklog) {
            console.log(`  âœ“ ${item.ticket.key} passed: ${(item.score * 100).toFixed(2)}% relevance, category=${item.category}`);
            return true;
          }
          return false;
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
      
      console.log(`Found ${relatedTickets.length} related tickets for ${issue.key}`);
      
      const mappedTickets = relatedTickets.map(item => ({
        key: item.ticket.key,
        summary: item.ticket.fields.summary,
        status: item.ticket.fields.status?.name || 'Unknown',
        relevance: Math.round(item.score * 100),
        category: item.category,
        assignee: item.ticket.fields.assignee?.displayName || 'Unassigned'
      }));

      return {
        ticketKey: issue.key,
        title: issue.fields.summary,
        suggestions: mappedTickets,
        confidence: mappedTickets.length > 0 ? 
          Math.min(0.5 + (mappedTickets[0].relevance / 100 * 0.5), 0.95) : 0,
        lastUpdated: new Date().toISOString(),
      };
    }).filter(s => s.suggestions.length > 0); // Only return tickets that have suggestions
    
    console.log('Total suggestions generated:', suggestions.length);

    return NextResponse.json({ suggestions });

  } catch (error) {
    console.error('Error fetching user suggestions:', error);
    return NextResponse.json(
      { error: 'Failed to fetch suggestions' },
      { status: 500 }
    );
  }
}
